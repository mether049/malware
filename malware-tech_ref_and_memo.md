# Anti-analysis/detection
- Anti-analysisに利用されるAPI，ファイル名，プロセス名，dll，レジストリ等の一覧まとめ<br>
[Collection of Anti-Malware Analysis Tricks.(2016-10)](https://forum.tuts4you.com/topic/38931-collection-of-anti-malware-analysis-tricks/)
## Injection/Hollowing
- 正規プロセス等のアドレス空間にコードを注入することで検知や分析を妨害するTechnique
- 利用される正規プロセス：svchost.exe,explorer.exe,regsvr32.exe,etc.
- Heaven's Gateと組み合わせて利用される場合あり
-
**ref:**<br>
- 各種Injection/Hollowingで利用されるAPIの一覧<br>
[HUNTING PROCESS INJECTION BY WINDOWSAPI CALLS (2019-11)](https://malwareanalysis.co/wp-content/uploads/2019/11/Hunting-Process-Injection-by-Windows-API-Calls.pdf)<br>
- 図で分かりやすく説明<br>
[Ten Process Injection Techniques: A Technical Survey Of Common And Trending Process Injection Techniques](https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)
- プログラムベースの説明<br>
[Code & Process Injection,Red Teaming Experiments](https://ired.team/offensive-security/code-injection-process-injection)

### Dll Injection
- 正規プロセス探索->プロセスのハンドル取得->メモリ領域確保->悪性DLL注入->実行
- e.g. CreateToolhelp32Snapshot,Process32First,Process32Next->OpenProcess->VirtualAllocEx->WriteProcessMemory->CreateRemoteThread<br>
[07b8f25e7b536f5b6f686c12d04edc37e11347c8acd5c53f98a174723078c365](https://www.virustotal.com/gui/file/07b8f25e7b536f5b6f686c12d04edc37e11347c8acd5c53f98a174723078c365/detection)
### Thread Execution Hijacking
- 正規プロセス，スレッド探索->スレッドのハンドル取得->スレッド停止->メモリ領域確保->悪性コード注入->EIP書き換え->実行
- e.g. CreateToolhelp32Snapshot,Thread32First,Thread32Next->OpenThread->SuspendThread->VirtualAllocEx->WriteProcessMemory->SetThreadContext->ResumeThread
[787cbc8a6d1bc58ea169e51e1ad029a637f22560660cc129ab8a099a745bd50e](https://www.virustotal.com/gui/file/787cbc8a6d1bc58ea169e51e1ad029a637f22560660cc129ab8a099a745bd50e/detection)
### Dll Injection Using SetWindowsHookEx(Hook Injection)
- Hooking:
> Hooking is a technique used to intercept function calls. 
- SetWindowsHookEx
> - The first argument is the type of event. The events reflect the range of hook types, and vary from pressing keys on the keyboard (WH_KEYBOARD) to inputs to the mouse (WH_MOUSE), CBT, etc. 
> - The second argument is a pointer to the function the malware wants to invoke upon the event execution.
> - The third argument is a module that contains the function.
> - The last argument to this function is the thread with which the hook procedure is to be associated. 
- dll読み込み->アドレス解決->正規プロセス，スレッドの探索->フック
- e.g. LoadLibrary->GetProcAddress->CreateToolhelp32Snapshot,Thred32First,Thread32Next->SetWindowsHookEx
[5d6ddb8458ee5ab99f3e7d9a21490ff4e5bc9808e18b9e20b6dc2c5b27927ba1](https://www.virustotal.com/gui/file/5d6ddb8458ee5ab99f3e7d9a21490ff4e5bc9808e18b9e20b6dc2c5b27927ba1/detection)
### Process Hollowing
- 正規プロセス作成(サスペンド状態)->空洞化->メモリ領域確保->悪性コード注入->エントリポイント設定->実行<br>
- e.g. CreateProcess->ZwUnmapViewOfSection(NtUnmapViewOfSection)->VirtualAllocEx->WriteProcessMemory->SetThreadContext->ResumeThread<br>
[eae72d803bf67df22526f50fc7ab84d838efb2865c27aef1a61592b1c520d144](https://www.virustotal.com/gui/file/eae72d803bf67df22526f50fc7ab84d838efb2865c27aef1a61592b1c520d144/detection)
### APC Injection
- プロセス，スレッド探索->アラート状態->ハンドル取得->キューに追加
- e.g. Createtoolhelp32Snapshot,Thread32First,Thread32Next->WaitForMultipleObjectEx->OpenThread->VirtualAllocEx->WriteProcessMemory->QueueUserAPC
- QueueUserAPC
> - First args: a handle to the target thread
> - Second args: a pointer to the function that the malware wants to run
> - Third args: the parameter that is passed to the function pointer. 

[f74399cc0be275376dad23151e3d0c2e2a1c966e6db6a695a05ec1a30551c0ad](https://www.virustotal.com/gui/file/f74399cc0be275376dad23151e3d0c2e2a1c966e6db6a695a05ec1a30551c0ad/detection)
### ATOM BOMBING
to do...
### Shell Tray Window Injection
to do...
### Shim Injection
to do...
### IAT and Inline Hooking
to do...
### ALPC Injection
to do...
### REFLECTIVE PE Injection
to do...
### LOCKPOS
to do...
### KERNEL CALLBACK TABLE
to do...
### CLIPBRDWNDCLASS
to do...
### PROGATE
to do...
### EARLY BIRD
to do...
### CONSOLE WINDOW CLASS
to do...
### TOOLTIP Process Injection
to do...
### Persistence
- **Applnit_Dlls**<br>
to do...
- **AppCertDlls**<br>
to do...
- **IFEO**<br>
to do...

## Heaven's Gate
- 0x33セグメントセレクターを使用して32ビット（WOW64）プロセスで64ビットコードを実行するTechnique<br>
- x86用ユーザモードデバッガでの追跡が難しい<br>
- WinDBG等のカーネルモードデバッガでは追跡することができる<br>
- 名前の由来はVX Heavenに投稿されたから<br>
- 少なくともtrickbot,locky,emotet等では利用されていた<br>
**ref:**<br>
[Knockin’ on Heaven’s Gate – Dynamic Processor Mode Switching(2012-09)](http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/)<br>
[The 0x33 Segment Selector (Heavens Gate)](https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html)<br>

## API obfuscation
[A Museum of API Obfuscation on Win32](https://www.symantec.com/content/en/us/enterprise/media/security_response/whitepapers/a_museum_of_api_obfuscation_on_win32.pdf)<br>
### Using GetProcAddress and GetModulehandleA
- GetProcAddressを利用して呼び出したいAPIのアドレスを動的に解決することで，APIの呼び出し解析を回避する
- GetProcAddressの引数は第一引数に対象dllのハンドルを指定(e.g. GetModuleHandleA("kernel32.dll"))し，第二引数にdllから呼び出したいAPI名を指定
```cpp
// Get a handle on kernel32.dll
HMODULE kernel32 = GetModuleHandleA("kernel32.dll");

// Define the prototype of 'OpenProcess' (see https://docs.microsoft.com/en-us/windows/desktop/api/processthreadsapi/nf-processthreadsapi-openprocess)
using OpenProcessPrototype = HANDLE(WINAPI*)(DWORD, BOOL, DWORD);

// Perform the dynamic resolving using GetProcAddress
OpenProcessPrototype OpenProcess = (OpenProcessPrototype)GetProcAddress(kernel32, "OpenProcess");
```
- GetProcAddressやGetModuleWのみインポートすること自体が怪しまれる可能性がある
- ref:
  - [Hidden in PEB Sight: Hiding Windows API Imports With a Custom Loader,2020-02](https://blog.christophetd.fr/hiding-windows-api-imports-with-a-customer-loader/)
  - [Salted algorithm - part 1,virusbulletin.,2014](https://www.virusbulletin.com/virusbulletin/2014/01/salted-algorithm-part-1)
### Using PEB
- GetProcAddressやGetModulehanleWのアドレスも動的に解決させることができる
- PEB(Process Environmental Block)の[PEB_LDR_DATA](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data)構造体や[LDR_DATA_TABLE_ENTRY](https://docs.microsoft.com/en-us/windows/win32/api/winternl/ns-winternl-peb_ldr_data#remarks)構造体のリストを反復処理して，目的のDLL名を探しアドレスを取得する
- 目的のDLLのメモリ内のエクスポートテーブルから呼び出す対象のAPIを探しアドレスを取得する
- ref:
  - [Hidden in PEB Sight: Hiding Windows API Imports With a Custom Loader,2020-02](https://blog.christophetd.fr/hiding-windows-api-imports-with-a-customer-loader/)
  - [Salted algorithm - part 1,virusbulletin.,2014](https://www.virusbulletin.com/virusbulletin/2014/01/salted-algorithm-part-1)

## PowerShell Script obfuscation
- 難読化ツール<br>
[Invoke-Obfuscation](https://github.com/danielbohannon/Invoke-Obfuscation)
- PS内の文字列(Mimikatz,DumpCreds,コメント，etc.)の置換のみでVirusTotal上でMimikatzの検知率を0にしたという検証<br>
[How to Bypass Anti-Virus to Run Mimikatz,2017](https://www.blackhillsinfosec.com/bypass-anti-virus-run-mimikatz/)
- Powershell Script内で用いられる難読化技術について
### Case-insensitive
- コマンドレット名や変数名に大文字，小文字を混ぜる
    - PowerShellでは区別されない
```
INvOke-eXpReSsiOn
```
### Alias
- コマンドのエイリアスを用いる
- エイリアスの確認方法
```
get-alias # すべてのエイリアスの確認
get-alias iex #iexのエイリアス(Invoke-Expression)の確認
```
- よく利用されるエイリアス
```
iex -> Invoke-Expression
sal -> Set-Alias
```
- エイリアスの設定
```
set-alias <Name> <Value>
sal ping iex
```
### Dot expression and amp expression(Invoke-Expression)
- 文字列で表現されたコマンドレットを実行
```
.("get-alias")
&('gal')
iex("GeT-AliAs")
```
### Combining characters
- 文字や文字列の結合
```
'i'+'ex'
```
### Backticks
- コマンドレットや変数にバッククォートを挿入
```
`i`e`x("`gal `gal")
```
### Split method
- 文字列の分割
```
'bob@alice'-split('@') -> bob alice
'bob@alice' -split '@' -split "i" -> bob al ce
```
### Join method
- リストの結合
```
"bob","alice" -join "@" -> bob@alice
```
### Concatenation operations
- 文字列の並べ替えおよび連結
```
"{1} {0}" -f "Alice","Bob" -> Bob Alice
"{1} {0}" -f "Alice",("{1}{2}{0}" -f "b","B","o") -> Bob Alice
```
### No Space
- 空白の省略
```
"bob","alice"-join"@"
```
### Pipe operator
- パイプによる引数の引き渡し
```
'Write-host 1' | iex
```
### $ENV variable
- 環境変数の値を文字列の作成等に利用
```
.($seLLId[1]+$shEllId[13]+'x') -> .(iex)
&($EnV:cOmSpEc[4,15,25]-JOIN'') -> &(iex)
```
### Encode
- xor
    - 文字，16進数，10進数等で指定可能
```
10-bxor"10"  -> 0
"0xa"-bxor10 -> 0
```
- base64
```
[System.Convert]::FromBase64String("Ym9iYWxpY2UK") -> bobalice
```
- zlib
```
New-Object System.IO.Compression.DeflateStream([iO.mEmoRySTream] [sysTEM.ConVert]::frOMBASE64STrING("Ym9iYWxpY2UK"))
```
- unicode
```
[System.Text.Encoding]::Unicode.GetString($unicodeBytes)
```
### Ascii code
- 文字などをasciiコードの10進数，16進数表記で示す
```
[string][char[]](0x69,0x65,0x58) -> i e X
```
### Replace method
- 文字や文字列を置換する
```
'i e x'-replace ' ','' -> ieX
```
### %(foreach-object)
- foreach-objectの省略系で%を利用
```
((0x69, 0x65, 0x58) | %{([char] [int] $_)})-jOIN'' -> ieX
```
### Comment out
- コメントアウト
```
<#bobalice#>
```
**ref:**<br>
[Powershell Static Analysis & Emotet results](https://hatching.io/blog/powershell-analysis)<br>

## Living Off The Land(LOL)
- システムに備わっている信頼性の高いツールを悪用する
- LOLで利用される各種Binary(LOLBin), Script(LOLScript), Library(LOLLib)のドキュメント<br>
[LOLBAS](https://lolbas-project.github.io/)<br>[GTFOBins(UNIX ver)](https://gtfobins.github.io/)
- LOLBinsとしてのの条件
> Be a Microsoft-signed file, either native to the OS or downloaded from Microsoft.
- LOLBinsで可能なこと
    - UAC Bypass,AppLocker Bypass,Dumping process memory,Credential theft,Log evasion/modification,Persistence,File operations,etc.
- よく利用されるLOLBins
    - [Certutil.exe](https://lolbas-project.github.io/lolbas/Binaries/Certutil/)
        - エンコードされたバイナリを，Certutil.exeでダウンロード->ダウンロードしたバイナリを，Certutil.exeでデコード->デコードしたバイナリを，[Forfiles.exe](https://lolbas-project.github.io/lolbas/Binaries/Forfiles/)で実行
    - [eventvwr.exe](https://lolbas-project.github.io/lolbas/Binaries/Eventvwr/)
    - [Msbuild.exe](https://lolbas-project.github.io/lolbas/Binaries/Msbuild/)
    - [Mshta.exe](https://lolbas-project.github.io/lolbas/Binaries/Mshta/)
    - [Odbcconf.exe](https://lolbas-project.github.io/lolbas/Binaries/Odbcconf/)
    - [Regasm.exe](https://lolbas-project.github.io/lolbas/Binaries/Regasm/) / [Regsvcs.exe](https://lolbas-project.github.io/lolbas/Binaries/Regsvcs/)
    - [Regsvr32.exe](https://lolbas-project.github.io/lolbas/Binaries/Regsvr32/)
    - [Wmic.exe](https://lolbas-project.github.io/lolbas/Binaries/Wmic/)
    - Powershell.exe
    - [Bitsadmin.exe](https://lolbas-project.github.io/lolbas/Binaries/Bitsadmin/)
    - Wingding.tff
    - Disk Cleanup
    - werfault.exe
### UAC bypass
- Windows Publisherによってデジタル署名されている且つ，セキュリティ保護されたフォルダに存在するプログラム(Trusted binary)はUACプロンプトを表示せずに，そのプログラムまたは，そのプログラムを経由して実行されるプログラムを管理者権限で実行させることができる
- マルウェアはUACなしで自身を管理者権限で実行させたり，セキュリティソフトのホワイトリストに自身を追加することができるようになる
- プログラムのデジタル署名の確認はWindows Sysinternalsのsigcheckと呼ばれるプログラムで確認することができる<br>

**ref:**
- UAC Bypassについて<br>
[Bypass User Account Control, MITRE ATT&CK](https://attack.mitre.org/techniques/T1088/)<br>
- UAC Bypassのメソッドの紹介及びそれらを利用するためのツール<br>
[UACMe](https://github.com/hfiref0x/UACME)
- fodhelper.exeによるUAC Bypass，[Trickbotによって利用されるとの情報あり](https://www.bleepingcomputer.com/news/security/trickbot-now-uses-a-windows-10-uac-bypass-to-evade-detection/)(2020-01-16)<br>
[First entry: Welcome and fileless UAC bypass](https://winscripting.blog/2017/05/12/first-entry-welcome-and-uac-bypass/)

## DGA
- ドメイン生成アルゴリズム<br>
- 数学的なアルゴリズムを利用して一定間隔ごとに異なる通信先ドメインを生成することにより，ドメイン名での検知を困難にする<br>
- 43ファミリのDGAに対してseedタイプ，DGAタイプ，エントロピー，TLD等様々な観点から比較<br>
[A Comprehensive Measurement Study of Domain Generating Malware,USENIX2016](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/plohmann)

## Fast Flux
- ドメインに対応するIPアドレスを短い期間で切り替えることにより，悪意のあるサイト(マルウェア配布，c2，フィッシング)を維持させる手法
- IPアドレスにはボットネットが用いられることがある
- 切り替えは平均5分

**ref:**<br>
[Fast Flux networks: What are they and how do they work?](https://www.welivesecurity.com/2017/01/12/fast-flux-networks-work/)

## DNS Tunneling
- C2通信としてDNSを利用し，ファイアウォールやプロキシでの検出を回避する
- e.g.
  - サブドメインにコマンド要求，処理結果等のデータを付加してDNSで各種レコードの問い合わせを行うことで，C2サーバとの通信を行う
  - Aレコードに含まれるIPアドレスの~オクテットの値をc2サーバからのコマンドとして解釈し処理する
  - TXTレコードに含まれるテキストをc2サーバからのコマンドとして解釈し処理する
- sample:
  - [477296cc6b85584f0706d2384f22b96e,PoisonFrog](https://www.virustotal.com/gui/file/0f20995d431abce885b8bd7dec1013cc1ef7c73886029c67df53101ea330436c/detection)
    - [ANY.RUN](https://app.any.run/tasks/3befa970-3e7f-47ee-9c2d-be5494b8e2f2/)
  - [6e86c57385d26a59c0df1580454b9967,Glimpse](https://www.virustotal.com/gui/file/eb1ded644e7491f3f60982be9652cbe40b0c819329927ea654cb43e40acb9b1c/detection)
    - [ANY.RUN](https://app.any.run/tasks/1009047d-aea0-46c9-918d-6fe6ecb68ee8/)
- ref:
  - [Chirp of the PoisonFrog](https://ironnet.com/blog/chirp-of-the-poisonfrog/)
  - [Glimpse to Glimpse](https://ironnet.com/blog/a-glimpse-into-glimpse/)

## Packing
- 実行形式を保持したまま，実行ファイルを圧縮
    - パッキング後のプログラムには展開ルーチン，圧縮されたオリジナルコードが含まれる
- オリジナルコードを静的解析するためにはアンパッキングが必要
- 特徴
    - 特徴的なセクション名
    - 可読性のある文字列が少ない
    - インポートされているAPIが少ない(オリジナルコードの展開ルーチンに利用するAPI?)
 - 展開ルーチンの流れ(簡易)
    - オリジナルコードをデコード
    - ローダによりオリジナルコードのIATを再構築
    - OEPに制御を移し，オリジナルコードを実行
 - プログラムをパッキングするまでの流れ(簡易)
    - PEヘッダから下記のパッキングに必要な各種情報(AddressOfEntryPoint,ImageBase,SectionTable(VirtualAddress,VirtualSize,PointerToRawData,SizeOfRawData),etc.)を取得
    - コードセクションのエンコード(PointerToRawからSizeOFRawData分の領域まで)
    - 展開ルーチンの追加
        - コードセクションの使われていない後方領域(0パディングされた領域)を利用(FileAlignment,VirtualSize,SizeOfRawDataから算出)
    - PEヘッダの修正
        - 展開ルーチン追加後のVirtualSize
        - 展開ルーチンの先頭を示すAddressOfEntryPoint
        - コードセクションへの書き込み属性の付与
 - 既知のパッカー
    - UPX
    - ASProtect
        - Stolen Bytesを利用
    - tELock
        - Import Redirectionを利用
    - CypherIT
      - オンラインでパッキング可能(Packing as a Searvice)
      - Pakcing以外にも，Anti-SandBox,Anti-MemoryScanner,Anti-VirtualMachine,Bypass-UAC,Persistence等の機能をバイナリに付与することができる
      - 上記の機能はAutoIT Scriptとしてバイナリに埋め込まれる
      - AutoIT Scriptは難読化されている
> - Change the character order.
> -Change the strings to hexadecimal.
> -XOR with constant values.
> -Rotate the strings.
> -Embed many non-ASCII characters.

## Anti-Unpacking
### Stolen Bytes(Stolen Codes)
- 展開ルーチンのコードの中にオリジナルコードの先頭部分(OEP付近)をあらかじめ含めて実行させることで，展開ルーチンによって展開させるオリジナルコードをその先頭部分から後ろのみにし，本来のOEPの特定を難化させる(展開されたオリジナルコードの領域監視によるOEP特定の難化)
### Import Redirection
- IATの再構築を妨害
- IATにAPIのアドレスではなく，APIを呼び出すための関数をsetする
    - 関数内
        - レジスタにAPIのアドレスをsetして，jmpしてAPIを呼び出し
        - スタックにAPIのアドレスをsetして，retでAPIを呼び出し

## Mutex
- 本来はプロセス間の同期や排他制御を行うことが目的に作成されるが，マルウェアでは１つのホストで２重で感染させるのを回避する目的で利用されることが多い。
- ロック状態で該当プロセスが終了すると，自動解放される
- Mutexは感染ホスト固有の情報を用いて作成される場合があるため，同一マルウェアでもシステムごとに異なるという可能性を考慮する必要がある
- e.g.
  - OpenMutex():Mutexの状態確認
  - CreateMutex():Mutexの作成
  - OpenMutex()で状態を確認→ロック状態の場合，自プロセス終了またはロックしているプロセス終了。アンロック状態の場合，Mutexの作成。
- ref:
  - [How Malware Generates Mutex Names to Evade Detection](https://isc.sans.edu/forums/diary/How+Malware+Generates+Mutex+Names+to+Evade+Detection/19429/#comments)
  
## Poisoning CRT Library
- C/C++ランタイム(CRT)ライブラリに悪性コードを注入，特定のランタイムライブラリ関数の改ざん
- libcmt.libやmsvcrt.libの上書き，不正なライブラリファイルの指定
  - 改ざんされた事例があるランタイム関数
    - __crtExitProcess():プロセスの終了。管理アプリケーションか否かのチェック
    - __scrt_common_main_seh():cランタイムライブラリ_mainCRTStartupのEntryPoint
    - _security_init_cookie():セキュリティチェックを行う関数。バッファオバーフローを防ぐ
    - _initterm():関数インポートテーブルのエントリー呼び出し
  - e.g.
    - DllEntryPoint() -> __DllmainCRTStartup() -> _CRT_INIT() -> _initterm() -> __imp_initterm() -> malicious_code() 
- コンパイル時点のレベルで改ざんされ，サプライチェーン攻撃として利用されることがある
    - e.g. ShadowPad,CCLeaner,Operation ShadowHammer,etc.
- ref:
   - [Analyzing C/C++ Runtime Library Code Tampering in Software Supply Chain Attacks](https://blog.trendmicro.com/trendlabs-security-intelligence/analyzing-c-c-runtime-library-code-tampering-in-software-supply-chain-attacks/)
   - [Mutex List,Hexacorn,2015](http://hexacorn.com/examples/2015-04-05_easter_bunny_with_a_bag_full_of_events.txt)

# Persistence
## Registry
- 利用されるWin32API
    - RegSetValue
- 利用されるレジストリ
```
- HKCU\Software\Microsoft\Windows\CurrentVersion\Run
- HKLM\Software\Microsoft\Windows\CurrentVersion\Run
- HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
- HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
- HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices
- HKLM\Software\Microsoft\Windows\CurrentVersion\RunServices
- HKCU\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
- HKLM\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
- HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
- HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
- HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnceEx
- HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\SharedTaskScheduler
```

# Shell Backdoor
- Web Shell等 
- 様々なShell Backdoor(PHP/ASP)<br>
[Shell Backdoor List - PHP / ASP Shell Backdoor List](https://www.kitploit.com/2020/01/shell-backdoor-list-php-asp-shell.html?utm_source=feedburner&utm_medium=feed&utm_campaign=Feed%3A+PentestTools+%28PenTest+Tools%29)

# rootkit
## LKM rootkit
- 動的にカーネルに組み込めるモジュールであるLKM(Loadable Kernel Module)を利用して，sys_call_tableの特定のカーネル関数のアドレスを任意の関数のアドレスへと書き換えることで，本来とは異なるカーネル関数であるrootkitのカーネル関数等が呼び出せるようになる(システムコールフック)
- sys_call_tableへのアクセスは特権モードが必要であるためLKMを利用される
- rootkitの関数内で本来呼び出されるはずの正規のカーネル関数をあえて呼び出すことで，正規の処理を行っているように見せかけることができる
- /proc/modulesからの隠ぺいも可能
- LKMについて
    - init_module関数...カーネルにロードする際に最初に実行される関数，LKM rootkitではsys_calltableを書き換える処理を記載
    - clean_module関数...カーネルからアンロードする際に実行される関数，LKM rootkitではsys_call_tableを元に戻す処理を記載
- LKMのロード
```
insmod [lkm_name].ko
```
- LKMのアンロード
```
rmmod [lkm_name].ko
```

**ref:**<br>
- LKMのrootkitへの応用について<br> 
[侵入者の不利な情報を隠すLKM rootkitの仕組み,2003](https://www.atmarkit.co.jp/fsecurity/rensai/rootkit03/rootkit02.html)<br>
- LKM rootkit(work on Linux kernels 2.6.32-38 and 4.4.0-22 )<br>
[Linux Rootkit](https://github.com/nurupo/rootkit)
- LKM rootkitその2(developed using linux kernel version 4.4.13)<br>
[rootkit-kernel-module](https://github.com/croemheld/lkm-rootkit)
- LKM rootkitその3(runs on kernel 2.6.x/3.x/4.x)<br>
[Reptile](https://github.com/f0rb1dd3n/Reptile)
- LKM rootkitその4(Tested on Linux kernel [4.19.62] & [4.15.0])<br>
[Sutekh](https://github.com/PinkP4nther/Sutekh)
